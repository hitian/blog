<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mysql on 不折腾不舒服</title><link>https://hitian.info/categories/mysql/</link><description>Recent content in mysql on 不折腾不舒服</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 12 Apr 2012 00:00:00 +0000</lastBuildDate><atom:link href="https://hitian.info/categories/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>sql笔记</title><link>https://hitian.info/post/sql-note/</link><pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate><guid>https://hitian.info/post/sql-note/</guid><description>一般数据库会根据使用的情况来设计, 为了保证性能一般链接的表不应该超过2个,
但是在数据统计汇总运算的时候就麻烦了, 往往需要查好多张表才能得到需要的数据.
如果查询很复杂的时候一次join好多张表会导致查询速度巨慢.
当然用php等动态语言把数据取出来进行运算也不错,就是需要写代码.
 能在数据库内完成的运算 当然想要直接在库内完成
使用临时表存储计算过程中的中间数据时隔不错的选择
使用临时表进行数据统计， 避免出现超过3个以上的join操作
&amp;ndash;以防万一先删除表
drop table if exists tmp_table;
&amp;ndash;创建临时表的时候加上temporary 关键字就行了
create temporary table tmp_table(uid bigint not null primary key, cityid int(10) unsigned, prov varchar(50), city varchar(50), group_id tinyint );
 &amp;ndash;把多个表中需要的数据组合在一起插入临时表中, 暂时没有的数据插入空字符串
insert into tmp_table select a.uid as uid, a.cityid as cityid,'','',0 from my_city a inner join my_op b on a.uid=b.uid where a.reg_date='2012-04-10' and b.ctime&amp;gt;0;
&amp;ndash;联合多表更新
update tmp_table a, my_city b set a.</description></item><item><title>用latin1来存储汉字真抓狂</title><link>https://hitian.info/post/latin1/</link><pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate><guid>https://hitian.info/post/latin1/</guid><description>mysql 是从4.0 升级上来的， 直接使用了latin1_swedish_ci 存储汉字，没想到带来了好多麻烦。
首先是查询的问题
mysql&amp;gt;select*frommy_citywherecity=’温州’;+—-+——+|id|city|+—-+——+|2|温州||3|梧州|+—-+——+2rowsinset(0.00sec)当然, 如果在city上建了唯一索引, 就会倒大霉&amp;hellip;
 然后是排序的问题
mysql&amp;gt;select*frommy_cityorderbycityasc;+—-+——+|id|city|+—-+——+|6|上海||2|温州||3|梧州||5|西安||7|重庆||4|安徽||8|北京|+—-+——+7rowsinset(0.00sec)这个顺序看起来更让人郁闷&amp;hellip;
临时解决方案:
ALTER TABLE `my_city` CHANGE `city` `city` VARCHAR( 25 ) CHARACTER SET latin1 COLLATE latin1_bin NULL DEFAULT NULL
修改字段的collate 为 latin1_bin
然后再来看
查询正常
mysql&amp;gt;select*frommy_citywherecity=’温州’;+—-+——+|id|city|+—-+——+|2|温州|+—-+——+1rowinset(0.00sec)排序部分正常
mysql&amp;gt;select*frommy_cityorderbycityasc;+—-+——+|id|city|+—-+——+|4|安徽||8|北京||6|上海||2|温州||3|梧州||5|西安||7|重庆|+—-+——+7rowsinset(0.00sec)要彻底解决还是要整个转换为gbk , 当然utf-8 会更好一点.</description></item><item><title>mysql表锁定中不支持清空操作?</title><link>https://hitian.info/post/mysql-table-lock/</link><pubDate>Thu, 01 Dec 2011 00:00:00 +0000</pubDate><guid>https://hitian.info/post/mysql-table-lock/</guid><description>偶然发现这个问题
mysql&amp;gt;locktabletest_mywrite;QueryOK,0rowsaffected(0.00sec)mysql&amp;gt;select*fromtest_my;Emptyset(0.00sec)mysql&amp;gt;insertintotest_myvalues(null,1,1);QueryOK,1rowaffected(0.00sec)mysql&amp;gt;select*fromtest_my;+—-+——+——–+|id|pid|enable|+—-+——+——–+|1|1|1|+—-+——+——–+1rowinset(0.00sec)mysql&amp;gt;truncatetabletest_my;ERROR1192(HY000):Can&amp;#39;t execute the given command because you have active lock ed tables or an active transaction TRUNCATE TABLE was not allowed under LOCK TABLES.
表锁中不可以使用清空操作, 这个让我很郁闷.
mysql&amp;gt;deletefromtest_my;QueryOK,1rowaffected(0.00sec)mysql&amp;gt;altertabletest_myauto_increment=1;QueryOK,0rowsaffected(0.05sec)Records:0Duplicates:0Warnings:0mysql&amp;gt;select*fromtest_my;Emptyset(0.00sec)mysql&amp;gt;insertintotest_myvalues(null,99,1);QueryOK,1rowaffected(0.00sec)mysql&amp;gt;select*fromtest_my;+—-+——+——–+|id|pid|enable|+—-+——+——–+|1|99|1|+—-+——+——–+1rowinset(0.00sec)mysql&amp;gt;分布操作: 先删除所有数据, 然后重新设置自增长的起始点却可以.</description></item></channel></rss>