<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>js on 哈哈哈</title><link>https://hitian.info/tags/js/</link><description>Recent content in js on 哈哈哈</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 05 Sep 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://hitian.info/tags/js/index.xml" rel="self" type="application/rss+xml"/><item><title>cocos2d-x 出现 call to OpenGL ES API with no current context</title><link>https://hitian.info/post/cocos2d-x-android-call-to-opengl-es-api-with-no-current-context/</link><pubDate>Fri, 05 Sep 2014 00:00:00 +0000</pubDate><guid>https://hitian.info/post/cocos2d-x-android-call-to-opengl-es-api-with-no-current-context/</guid><description>环境 cocos2d-x 2.2.2 + js
游戏的某些功能界面在Android出现了很奇怪的黑块, LOG记录到
E/libEGL (30687): call to OpenGL ES API with no current context (logged once per thread)
google一下, 大概的原因可能是在非UI线程上操作场景上的图片资源导致的. 但是网上的情况绝大多数情况出现在 java 操作 c++ 层时出现的, 而我们是直接出现在js的回调方法中.
回调是由某sdk执行的, 通过 java -&amp;gt; c++ -&amp;gt; js 一层层回来的.
也就是说最终js的回调有可能是执行在非ui线程里的, 所以在这里更新界面有可能会出现问题.
囧&amp;hellip;
推测
js无法决定自己运行在什么线程里, 但是可以控制界面更新在UI线程里操作.
我们的流程是这样的.
sdk -&amp;gt; someService -&amp;gt; controller -&amp;gt; view
那其实我们可以打断someService 和 controller 之间的直接调用关系. 分成两步来执行.
sdk -&amp;gt; someService -&amp;gt; [write status mark &amp;amp; store params]
写完状态就可以直接返回了. 剩下的事情由游戏的循环来做. 游戏的循环本来就是负责界面更新的, 所以肯定不会有问题.</description></item><item><title>关于异步的一点点其他东西</title><link>https://hitian.info/post/a-little-things-about-asynchronous/</link><pubDate>Thu, 09 Feb 2012 00:00:00 +0000</pubDate><guid>https://hitian.info/post/a-little-things-about-asynchronous/</guid><description>当一个网页包含大量的内容, 而只有其中的一小部分需要是动态内容(显示用户名, 积分等)时, 通常整个页面采用html静态页面, 并使用js来加载和改变动态的部分.
但是像这样, 如果js加载速度很慢的话, 会导致之下的页面停止渲染&amp;hellip;
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;demo6-1&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;content...&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;get_something_api.php&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;p&amp;gt;content...&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 于是我们将js写在页面下面, 等页面渲染的差不多了再加载它
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;demo6-1&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;content...&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;content...&amp;lt;/p&amp;gt; &amp;lt;a href=&amp;#34;demo6.html&amp;#34;&amp;gt;demo6.html&amp;lt;/a&amp;gt; | &amp;lt;a href=&amp;#34;demo6-2.html&amp;#34;&amp;gt;demo6-2.html&amp;lt;/a&amp;gt; | &amp;lt;a href=&amp;#34;demo6-3.html&amp;#34;&amp;gt;demo6-3.html&amp;lt;/a&amp;gt; &amp;lt;img src=&amp;#34;27218b6e.jpg&amp;#34; width=&amp;#34;1920&amp;#34; height=&amp;#34;1200&amp;#34; border=&amp;#34;0&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;get_something_api.php&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 看起来是一个比较好的解决方案, 但是新的问题出现了.
当由于网络或者程序执行效率的问题js的速度很慢的时候, 等待js加载过程中, 页面是可以正常操作的, 但是一旦操作有同一服务器上不同资源的请求时, 这个请求就完全卡住了, 例如点击页面上的链接. 同一服务器下资源并不能很好的多线程同时请求.
本地用sleep模拟一个需要长时间才能完成的响应.
&amp;lt;?php //do something and need some times header(&amp;#39;Content-Type:application/x-javascript&amp;#39;); sleep(5); echo &amp;#34;alert(&amp;#39;results&amp;#39;);&amp;#34;; ?&amp;gt; 在对get_something_api.</description></item><item><title>解决ie6 恶心的动态gif图片问题</title><link>https://hitian.info/post/ie6-gif-bug/</link><pubDate>Fri, 25 Nov 2011 00:00:00 +0000</pubDate><guid>https://hitian.info/post/ie6-gif-bug/</guid><description>&lt;p>将改变img标签的src的事件触发写在a标记的onclick里面 在ie6下会导致切换后新的图片无法加载.&lt;/p>
&lt;p>今天又发现了另一个恶心的问题&lt;/p></description></item><item><title>js常用操作</title><link>https://hitian.info/post/js-tools/</link><pubDate>Wed, 24 Aug 2011 00:00:00 +0000</pubDate><guid>https://hitian.info/post/js-tools/</guid><description>/** * js常用操作类 */ var myTools = window.myTools = { // getElementById g: function(id){ return document.getElementById(id); }, // getElementsByTagName t: function(name){ return document.getElementsByTagName(name); }, writeHTML: function(id, content){ var target = this.g(id); if (target != null) { target.innerHTML = content; } }, //计算字符串长度， 中文算两个字 slen: function(str){ c = 0; for (var i = 0; i &amp;lt; str.length; i++) (str.charCodeAt(i) &amp;gt; 255) ? c += 2 : c++; return c; }, // 还原html HtmlToStr: function(vStr){ vStr = vStr.</description></item><item><title>js本地存储和cookie操作</title><link>https://hitian.info/post/js-localstorage/</link><pubDate>Sun, 21 Aug 2011 00:00:00 +0000</pubDate><guid>https://hitian.info/post/js-localstorage/</guid><description>/** * tian */ //storage tools; var st = { sset : function(a, b) { storage.set(a, b); }, sget : function(a) { return storage.get(a); }, sdel : function(a) { storage.del(a); }, cset : function(a, b) { var c = [], _para = {}; for ( var d = 0, _len = arguments.length; d &amp;lt; _len; d++) { c[d] = arguments[d]; } ; _para.exps = typeof (c[2]) != &amp;#34;undefined&amp;#34; ? Math.ceil(c[2] / (3600 * 24)) : undefined; _para.</description></item></channel></rss>